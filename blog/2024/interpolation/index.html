<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> All Flows are One Flow | RectifiedFlow </title> <meta name="author" content="RectifiedFlow "> <meta name="description" content="Affine Interpolations Result in Equivalent Rectified Flows"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://rectifiedflow.github.io/blog/2024/interpolation/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.min.css" integrity="sha256-q9ba7o845pMPFU+zcAll8rv+gC+fSovKsOoNQ6cynuQ=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github.min.css" integrity="sha256-Oppd74ucMR5a5Dq96FxjEzGF7tTw2fZ/6ksAqDCM8GY=" crossorigin="anonymous" media="screen and (prefers-color-scheme: light)"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github-dark.min.css" integrity="sha256-nyCNAiECsdDHrr/s2OQsp5l9XeY2ZJ0rMepjCT2AkBk=" crossorigin="anonymous" media="screen and (prefers-color-scheme: dark)"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/diff2html@3.4.47/bundles/css/diff2html.min.css" integrity="sha256-IMBK4VNZp0ivwefSn51bswdsrhk0HoMTLc2GqFHFBXg=" crossorigin="anonymous"> <link defer rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css"> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/mermaid@10.7.0/dist/mermaid.min.js" integrity="sha256-TtLOdUA8mstPoO6sGvHIGx2ceXrrX4KgIItO06XOn8A=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js" integrity="sha256-1rA678n2xEx7x4cTZ5x4wpUCj6kUMZEZ5cxLSVSFWxw=" crossorigin="anonymous"></script> <script>let mermaidTheme=determineComputedTheme();document.addEventListener("readystatechange",()=>{"complete"===document.readyState&&(document.querySelectorAll("pre>code.language-mermaid").forEach(e=>{const t=e.textContent,d=e.parentElement;d.classList.add("unloaded");let a=document.createElement("pre");a.classList.add("mermaid");const n=document.createTextNode(t);a.appendChild(n),d.after(a)}),mermaid.initialize({theme:mermaidTheme}),"undefined"!=typeof d3&&window.addEventListener("load",function(){d3.selectAll(".mermaid svg").each(function(){var e=d3.select(this);e.html("<g>"+e.html()+"</g>");var t=e.select("g"),d=d3.zoom().on("zoom",function(e){t.attr("transform",e.transform)});e.call(d)})}))});</script> <script src="https://cdn.jsdelivr.net/npm/diff2html@3.4.47/bundles/js/diff2html-ui.min.js" integrity="sha256-eU2TVHX633T1o/bTQp6iIJByYJEtZThhF9bKz/DcbbY=" crossorigin="anonymous"></script> <script>let diff2HtmlTheme=determineComputedTheme();document.addEventListener("readystatechange",()=>{"complete"===document.readyState&&document.querySelectorAll("pre>code.language-diff2html").forEach(e=>{const t=e.textContent,d=e.parentElement;d.classList.add("unloaded");let l=document.createElement("div");l.classList.add("diff2html"),d.after(l),new Diff2HtmlUI(l,t,{colorScheme:diff2HtmlTheme,drawFileList:!0,highlight:!0,matching:"lines"}).draw()})});</script> <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.min.js" integrity="sha256-MgH13bFTTNqsnuEoqNPBLDaqxjGH+lCpqrukmXc8Ppg=" crossorigin="anonymous"></script> <script>document.addEventListener("readystatechange",()=>{"complete"===document.readyState&&document.querySelectorAll("pre>code.language-geojson").forEach(e=>{const t=e.textContent,a=e.parentElement;a.classList.add("unloaded");let o=document.createElement("div");o.classList.add("map"),a.after(o);var n=L.map(o);L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png",{maxZoom:19,attribution:'&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'}).addTo(n);let d=L.geoJSON(JSON.parse(t)).addTo(n);n.fitBounds(d.getBounds())})});</script> <script defer src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js" integrity="sha256-0q+JdOlScWOHcunpUk21uab1jW7C1deBQARHtKMcaB4=" crossorigin="anonymous"></script> <script>$(document).ready(function(){var t=null,a=null,e=null,n="";$(".language-chartjs").each(function(){a=$(this),t=$("<canvas></canvas>"),n=a.text(),a.text("").append(t),(e=t.get(0).getContext("2d"))&&n&&new Chart(e,JSON.parse(n))&&a.attr("data-processed",!0)})});</script> <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js" integrity="sha256-QvgynZibb2U53SsVu98NggJXYqwRL7tg3FeyfXvPOUY=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/theme/dark-fresh-cut.js" integrity="sha256-sm6Ui9w41++ZCWmIWDLC18a6ki72FQpWDiYTDxEPXwU=" crossorigin="anonymous"></script> <script>let echartsTheme=determineComputedTheme();document.addEventListener("readystatechange",()=>{"complete"===document.readyState&&document.querySelectorAll("pre>code.language-echarts").forEach(e=>{const t=e.textContent,a=e.parentElement;a.classList.add("unloaded");let r=document.createElement("div");if(r.classList.add("echarts"),a.after(r),"dark"===echartsTheme)var n=echarts.init(r,"dark-fresh-cut");else n=echarts.init(r);n.setOption(JSON.parse(t)),window.addEventListener("resize",function(){n.resize()})})});</script> <script defer src="https://cdn.jsdelivr.net/npm/vega@5.27.0/build/vega.min.js" integrity="sha256-Yot/cfgMMMpFwkp/5azR20Tfkt24PFqQ6IQS+80HIZs=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/vega-lite@5.16.3/build/vega-lite.min.js" integrity="sha256-TvBvIS5jUN4BSy009usRjNzjI1qRrHPYv7xVLJyjUyw=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/vega-embed@6.24.0/build/vega-embed.min.js" integrity="sha256-FPCJ9JYCC9AZSpvC/t/wHBX7ybueZhIqOMjpWqfl3DU=" crossorigin="anonymous"></script> <script>let vegaTheme=determineComputedTheme();document.addEventListener("readystatechange",()=>{"complete"===document.readyState&&document.querySelectorAll("pre>code.language-vega_lite").forEach(e=>{const t=e.textContent,a=e.parentElement;a.classList.add("unloaded");let d=document.createElement("div");d.classList.add("vega-lite"),a.after(d),"dark"===vegaTheme?vegaEmbed(d,JSON.parse(t),{theme:"dark"}):vegaEmbed(d,JSON.parse(t))})});</script> <script defer src="https://tikzjax.com/v1/tikzjax.js" integrity="sha256-+1qyucCXRZJrCg3lm3KxRt/7WXaYhBid4/1XJRHGB1E=" crossorigin="anonymous"></script> <script src="/assets/js/typograms.js?63f3caa50c7a9624f953b3aec207afa6"></script> <script>document.addEventListener("readystatechange",()=>{"complete"===document.readyState&&document.querySelectorAll("pre>code.language-typograms").forEach(e=>{const t=e.textContent,n=e.parentElement.parentElement;let a=document.createElement("pre");a.classList.add("typogram");const d=create("\n"+t,.3,!1);a.appendChild(d),n.appendChild(a),n.removeChild(e.parentElement)})});</script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "All Flows are One Flow",
            "description": "Affine Interpolations Result in Equivalent Rectified Flows",
            "published": "December 10, 2024",
            "authors": [
              
              {
                "author": "Rectified Flow Group",
                "authorURL": "https://example.com",
                "affiliations": [
                  {
                    "name": "UT Austin",
                    "url": ""
                  }
                ]
              }
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">RectifiedFlow</span> </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>All Flows are One Flow</h1> <p>Affine Interpolations Result in Equivalent Rectified Flows</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#point-wisely-transformable-interpolations">Point-wisely Transformable Interpolations</a> </div> <ul> <li> <a href="#tl-dr">TL; DR</a> </li> <li> <a href="#same-transform-on-interpolations-and-rectified-flows">Same Transform on Interpolations and Rectified Flows</a> </li> </ul> <div> <a href="#equivalence-of-affine-interpolations">Equivalence of Affine Interpolations</a> </div> <ul> <li> <a href="#straight-spherical-and-ddim-interpolation">Straight, Spherical and DDIM interpolation</a> </li> <li> <a href="#pointwise-transformability-between-affine-interpolations">Pointwise Transformability Between Affine Interpolations</a> </li> <li> <a href="#converting-pretrained-rf-velocity">Converting Pretrained RF Velocity</a> </li> </ul> <div> <a href="#implications-on-loss-functions">Implications on Loss Functions</a> </div> <ul> <li> <a href="#straight-vs-spherical-same-train-time-weight">Straight vs Spherical: Same Train Time Weight</a> </li> </ul> </nav> </d-contents> <p>The choice of the interpolation process can significantly impact inference performance and speed, and it may initially seem that this decision must be made during the pre-training phase. In this blog, however, we demonstrate that it is possible to convert between different affine interpolation schemes at inference time, without retraining the model. The <strong>transformations</strong> applied to the interpolation are <strong>exactly the same</strong> as those applied to the rectified flow. For affine interpolation schemes, this can be achieved with a simple rescaling of the time \(t\) and the input \(x\). Building on this, we will show that these interpolations yield essentially <strong>equivalent</strong> rectified flow dynamics and identical rectified couplings.</p> <p>For detailed proofs, please refer to the flow book.</p> <h2 id="point-wisely-transformable-interpolations">Point-wisely Transformable Interpolations</h2> <h3 id="tl-dr">TL; DR</h3> <p>We show that, if two processes \(\{X_t\}\) and \(\{X'_t\}\) are related pointwise by</p> \[X'_t = \phi_t(X_t),\] <p>for some differentiable and invertible maps \(\phi: (t, x) \mapsto \phi_t(x)\) and \(\tau: t \mapsto \tau_t\), then their corresponding rectified flows, \(\{Z_t\}\) and \(\{Z'_t\}\), satisfy the <strong>same</strong> relation:</p> \[Z'_t = \phi_t(Z_{\tau_t}),\] <p>provided that this relation holds at initialization, i.e., \(Z'_0 = \phi_t(Z_0)\).</p> <p>This result suggests that the rectified flows of pointwisely transformable interpolations are essentially the same, up to the same pointwise transform. Furthermore, if two interpolations \(X_t = \texttt I_t(X_0, X_1)\) and \(X'_t = \texttt I_t(X_0, X_1)\) are constructed from the same coupling \((X_0, X_1)\), then they yield that same rectified coupling \((Z_0, Z_1') = (Z_0, Z_1)\).</p> <p>Define \(\{X'_t\} = \texttt{Transform}(\{X_t\})\) as the pointwise transform above. The result suggests that \(\texttt{Rectify}(\cdot)\) is an <strong>equivariant</strong> map under these pointwise transforms:</p> \[\texttt{Rectify}(\texttt{Transform}(\{X_t\})) = \texttt{Transform}(\texttt{Rectify}(\{X_t\})).\] <h3 id="same-transform-on-interpolations-and-rectified-flows">Same Transform on Interpolations and Rectified Flows</h3> <blockquote> <p><strong>Definition 1</strong>: Two stochastic processes \(\{X_t\}\) and \(\{X'_t\}\) are said to be <strong>pointwisely transformable</strong> if</p> \[X'_t = \phi_t(X_{\tau_t}), \quad \forall t \in [0, 1],\] <p>where \(\tau: [0,1] \to [0,1]\) and \(\phi: [0,1] \times \mathbb{R}^d \to \mathbb{R}^d\) for \(t \in [0,1]\) are differentiable maps, and \(\phi_t\) is invertible for all \(t \in [0,1]\).</p> </blockquote> <p>Building upon the notion of pointwise transformability, we have:</p> <blockquote> <p><strong>Theorem 1:</strong> Assume that \(\{X_t\}\) and \(\{X'_t\}\) are pointwise transformable. Let \(\{v_t\}\) and \(\{v'_t\}\) be their respective RF velocity fields, and let $\phi$ and $t$ be the corresponding interpolation transformation maps. Then we have</p> \[v'_t(x) = \partial_t \phi_t(\phi_t^{-1}(x)) + \nabla \phi_t(\phi_t^{-1}(x))^\top v_{\tau_t}(\phi_t^{-1}(x)) \dot{\tau}_t. \tag{1}\] <p>In addition, let \(\{z_t\}\) be a trajectory of the rectified flow of \(\{X_t\}\), satisfying \(\frac{\mathrm d}{\mathrm dt} z_t = v_t(z_t).\) Then a curve \(\{z'_t\}\) satisfies \(z'_t = \phi_t(z_{\tau_t})\), \(\forall t \in [0, 1]\) if and only if it is the trajectory of the rectified flow of \(\{X'_t\}\) initialized from \(z'_0 = \phi_0(z_{\tau_0})\).</p> </blockquote> <p>Furthermore, under the additional requirement that \(\tau(0)=0\), let \(\frac{\mathrm d}{\mathrm dt}Z_t=v_t(Z_t)\) be the rectified flow of \(\{X_t\}\) (initialized with \(Z_0=X_0\) by default). Then \(Z'_t=\phi_t(Z_{\tau_t})\) is the rectified flow of \(\{X_t'\}\) with the specific initialization</p> \[\frac{\mathrm d}{\mathrm dt} Z'_t = v'_t(Z_t'), \quad \forall t \in [0,1], \;\text{and}\; Z_0' = \phi_0(Z_{\tau_0}).\] <p>This result has two implications:</p> <p><strong>Same Transform between Interpolations and Rectified Flows</strong></p> <p>Assume the same conditions as Theorem 1, with the additional assumption that \(\tau(0) = 0\). Let \(\{Z_t\}\) and \(\{Z'_t\}\) be the rectified flows of \(\{X_t\}\) and \(\{X'_t\}\), respectively. Then \(Z'_t = \phi_t(Z_{\tau_t})\) for all \(t \in [0, 1]\).</p> <p><strong>Equivalent Rectified Couplings</strong></p> <p>If \(\{X_t\}\) and \(\{X'_t\}\) are constructed from the same coupling \((X_0, X_1) = (X'_0, X'_1),\) and they satisfy the condition in Theorem 1 with \(\tau(0) = 0\) and \(\tau(1) = 1\), then their rectified flow yields the same coupling, that is, \((Z_0, Z_1) = (Z'_0, Z'_1).\)</p> <h2 id="equivalence-of-affine-interpolations">Equivalence of Affine Interpolations</h2> <p>We now consider a specific class of interpolations called <em>affine interpolations</em>, defined as \(X_t = \alpha_t X_1 + \beta_t X_0\) where \(\alpha_t\) and \(\beta_t\) satisfy the conditions \(\alpha_0 = \beta_1 = 0\) and \(\alpha_1 = \beta_0 = 1\), as well as \(\alpha_t\) is monotonically increasing and \(\beta_t\) monotonically decreasing.</p> <h3 id="straight-spherical-and-ddim-interpolation">Straight, Spherical and DDIM interpolation</h3> <p><strong>Straight Line Interpolation</strong> (<code class="language-plaintext highlighter-rouge">straight</code> or <code class="language-plaintext highlighter-rouge">lerp</code>)</p> \[\begin{aligned} \alpha_t &amp; = t, &amp; \beta_t &amp; = 1 - t \\ \dot{\alpha}_t &amp; = 1, &amp; \dot{\beta}_t &amp; = -1 \end{aligned}\] <ul> <li>This interpolation follows a straight line connecting the source and target distributions with a constant speed.</li> </ul> <p><strong>Spherical Interpolation</strong> (<code class="language-plaintext highlighter-rouge">spherical</code> or <code class="language-plaintext highlighter-rouge">slerp</code>)</p> \[\begin{aligned} \alpha_t &amp; = \sin\left(\frac{\pi}{2} t\right), &amp; \beta_t &amp; = \cos\left(\frac{\pi}{2} t\right) \\ \dot{\alpha}_t &amp; = \frac{\pi}{2} \cos\left(\frac{\pi}{2} t\right), &amp; \dot{\beta}_t &amp; = -\frac{\pi}{2} \sin\left(\frac{\pi}{2} t\right) \end{aligned}\] <ul> <li>Spherical interpolation traces a curved path rather than a straight line.</li> </ul> <p><strong>DDIM / VP ODE Interpolation</strong></p> \[\alpha_t = \exp\left(- \frac{1}{4}a(1-t)^2 - \frac{1}{2}b(1-t)\right), \quad \beta_t = \sqrt{1 - \alpha_t^2}, \quad a=19.9, b=0.1\] <ul> <li>This also yields a spherical trajectory, but with a non-uniform speed defined by \(\alpha_t\).</li> </ul> <h3 id="pointwise-transformability-between-affine-interpolations">Pointwise Transformability Between Affine Interpolations</h3> <p>We now show that <strong>all affine interpolations are pointwise transformable</strong> by appropriately scaling both the time and the input. Then, according to the two corollaries above, their rectified flows can be transformed pointwise using the same mappings as those used between the interpolations, ultimately yielding the same rectified couplings. This is also observed by other authors.</p> <blockquote> <p>Consider two affine interpolation processes of same coupling \((X_0, X_1)\):</p> \[X_t = \alpha_t X_1 + \beta_t X_0 \quad \text{and} \quad X_{t}' = \alpha_{t}' X_1 + \beta_{t}' X_0,\] <p>Then we have</p> \[X_t' = \frac{1}{\omega_t} X_{\tau_t}, \quad \forall t \in [0,1],\] <p>where \(\tau_t\) and \(\omega_t\) are found by solving:</p> \[\frac{\alpha_{\tau_t}}{\beta_{\tau_t}} = \frac{\alpha'_t}{\beta'_t}, \quad \omega_t = \frac{\alpha_{\tau_t}}{\alpha'_t} = \frac{\beta_{\tau_t}}{\beta'_t}, \quad \forall t \in (0, 1) \tag{2}\] <p>with the boundary condition:</p> \[\omega_0 = \omega_1 = 1, \quad \tau_0 = 0, \quad \tau_1 = 1.\] <p>There is one unique solution of \((\tau_t, \omega_t)\) in \((2)\) since \(\alpha'_t / \beta'_t \geq 0\) and \(\alpha_t / \beta_t\) is strictly increasing for \(t \in [0,1]\).</p> </blockquote> <p>In practice, we determine the time scaling function \(\tau_t\) in two ways. For simple cases, \(\tau_t\) can be computed analytically. For more complex scenarios, a numerical approach, such as a <a href="">simple binary search</a>, can be used to find \(\tau_t\) efficiently. Check the notebook for implementation.</p> <div class="l-page" style="display: flex;"> <iframe src="/assets/plotly/interp_tau_ddim_spherical.html" frameborder="0" scrolling="no" height="430px" width="49%"></iframe> <iframe src="/assets/plotly/interp_tau_straight_spherical.html" frameborder="0" scrolling="no" height="430px" width="49%"></iframe> </div> <p>Substituting the notion of \(\tau\) and \(\omega\) into the theorem 1, we have:</p> <blockquote> <p><strong>Theorem 2</strong>: Assume \(\{X_t\}\) and \(\{X'_t\}\) are two affine interpolations:</p> <p>1) Their respective rectified flows \(\{Z_t\}\) and \(\{Z'_t\}\) satisfy:</p> \[Z'_t = \omega_t^{-1} Z_{\tau_t}, \quad \forall t \in [0, 1].\] <p>2) Their rectified couplings are equivalent:</p> \[(Z_0, Z_1) = (Z'_0, Z'_1).\] <p>3) Their RF velocity fields \(v_t\) and \(v'_t\) satisfy:</p> \[v'_t(x) = \frac{1}{\omega_t} \left( \dot{\tau}_t v_{\tau_t}(\omega_t x) - \dot{\omega}_t x \right). \tag{3}\] </blockquote> <p>The figure below shows the conversion between the <code class="language-plaintext highlighter-rouge">straight</code> and <code class="language-plaintext highlighter-rouge">spherical</code> interpolations using a binary search method. Observe that once converted, the trajectory of the original <code class="language-plaintext highlighter-rouge">straight</code> interpolation matches perfectly with the newly derived <code class="language-plaintext highlighter-rouge">straight</code> curve, confirming that these interpolations are indeed pointwise transformable. See the flow book for explicit solution.</p> <div class="l-page"> <iframe src="/assets/plotly/interp_affine_interp_conversion.html" frameborder="0" scrolling="no" height="630px" width="100%"></iframe> </div> <h3 id="converting-pretrained-rf-velocity">Converting Pretrained RF Velocity</h3> <p>Now, let’s take a pretrained straight rectified flow and transform it into a curved trajectory. See the notebook for implementation details.</p> <div class="l-page"> <iframe src="/assets/plotly/interp_1rf_straight_to_spherical.html" frameborder="0" scrolling="no" height="630px" width="100%"></iframe> </div> <p><strong>Trajectory Considerations</strong> As the number of sampling steps increases, the trajectories for \(Z_1\) and \(Z_1'\) should converge to the same points, and the mean squared error between them should also decrease.</p> <p>However, even though different paths theoretically lead to the same rectified endpoint \(Z_1\), the intermediate trajectories \(\{Z_t\}\) they follow are not identical. In practice, when running simulations, we must discretize these trajectories, making perfect solutions unattainable. For this reason, <strong>choosing straighter trajectories is generally preferable</strong>: the straighter the path, the lower the discretization error, and the more faithful the results. Thanks to the transformation relations described above, it is possible to convert the interpolation scheme of a pretrained model without retraining, enabling the identification of a scheme that yields straighter trajectories for \(\{Z_t\}\).</p> <h2 id="implications-on-loss-functions">Implications on Loss Functions</h2> <p>Assume that we have trained a model \(\hat{v}_t\) for the RF velocity field \(v_t\) under an affine interpolation. Using the formulas from the previous section, we can convert it to a model \(\hat{v}'_t\) for \(v'_t\) corresponding to a different interpolation scheme at the post-training stage. This raises the question of what properties the converted model \(\hat{v}'_t\) may have compared to the models trained directly on the same interpolation, and whether it suffers from performance degradation due to the conversion.</p> <p>We show here that using different affine interpolation schemes during training is equivalent to applying <strong>different time-weighting</strong> in the loss function, as well as an affine transform on the parametric model. Unless \(\omega_t\) and \(\tau_t\) are highly singular, the conversion does not necessarily degrade performance.</p> <p>Specifically, assume we have trained a parametric model \(v_t(x; \theta)\) to approximate the RF velocity \(v_t\) of interpolation \(X_t = \alpha_t X_1 + \beta_t X_0\), using the mean square loss:</p> \[\mathcal L(\theta) = \int_0^1 \mathbb E\left[ \eta_t \left \| \dot X_t - v_t(X_t;\theta)\right\|^2 \right] \mathrm dt \tag{4}\] <p>After training, we may convert the obtained model \(v_t(x; \theta)\) to an approximation of \(v'_t\) of a different interpolation \(X'_t = \alpha_t X_1 + \beta_t X_0\) via:</p> \[v'_t(x; \theta) = \frac{\dot{\tau}_t}{\omega_t} v_{\tau_t}(\omega_t x; \theta) - \frac{\dot{\omega}_t}{\omega_t} x,\] <p>On the other hand, if we train \(v'_t(x; \theta)\) directly to approximate \(v'_t\) of interpolation \(X'_t = \alpha'_t X_1 + \beta'_t X_0\), the loss function is:</p> \[\mathcal L'(\theta) = \int_0^1 \mathbb{E} \left[ \eta'_t \left\| \dot{X}'_t - v'_t(X'_t; \theta) \right\|^2 \right] \mathrm dt \tag{5}\] <p>When matching the loss \((4)\) and \((5)\), we find that these two training schemes are identical, except for the following time-weighting and reparametrization relationship:</p> \[\eta'_t = \frac{\omega_t^2}{\dot{\tau}_t} \eta_{\tau_t}, \quad v'_t(x; \theta) = \frac{\dot{\tau}_t}{\omega_t} v_{\tau_t}(\omega_t x; \theta) - \frac{\dot{\omega}_t}{\omega_t} x.\] <p>In other words, <strong>training with different interpolation schemes simply only introduces different training time weights and model parameterizations.</strong></p> <h3 id="straight-vs-spherical-same-train-time-weight">Straight vs Spherical: Same Train Time Weight</h3> <p>In the case where \(X_t = tX_1 + (1-t)\) is the straight interpolation, and \(X_t'=\alpha_t'X_1 + \beta'_t X_0\) is the affine interpolation, when</p> \[\dot \alpha_t' \beta_t' - \alpha_t \beta_t' = \text{const},\] <p>we’ll have \(\text{const} \cdot \eta_t' = \eta_{\tau_t}\), meaning the training time weight scale remains the same across all time.</p> <p>For example, this holds for spherical interpolation</p> \[X'_t = \sin\left(\frac{\pi t}{2}\right) X_1 + \cos\left(\frac{\pi t}{2}\right) X_0,\] <p>where</p> \[\eta'_t = \frac{2}{\pi} \eta_{\tau_t}, \quad \tau_t = \frac{\tan\left(\frac{\pi t}{2}\right)}{\tan\left(\frac{\pi t}{2}\right)+1}.\] <p>In this case, training \(v_t\) with straight interpolation using a uniform weight \(\eta_t = 1\) is equivalent to training \(v'_t\) with spherical interpolation, <strong>also using a uniform weight</strong> \(\eta'_t = 1\), the only difference lies in the model parameterization:</p> \[v'_t(x, \theta) = \frac{\pi \omega_t}{2} \left( v_{\tau_t}(\omega_t x, \theta) + \left( \cos\left(\frac{\pi}{2} t\right) - \sin\left(\frac{\pi}{2} t\right) \right) x \right).\] <p>Given that the variable scaling factor \(\omega_t = (\sin(\frac{\pi}{2} t) + \cos(\frac{\pi}{2} t))^{-1}\) is bounded in \([1/\sqrt{2}, 1]\), this reparameterization may not significantly impact performance. Overall, the choice of using straight or spherical interpolation might have limited impact in terms of training performance.</p> <div class="l-page"> <iframe src="/assets/plotly/interp_straight_spherical_rf.html" frameborder="0" scrolling="no" height="630px" width="100%"></iframe> </div> <p>Here, we independentely trained 2 rectified flow with mlp. Note that the final couplings \((Z_0,Z_1)\) and \((Z_0',Z_1')\) are the same.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 RectifiedFlow . Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"post-stochastic-sampler-langevin-as-guardrail",title:"Stochastic Sampler: Langevin as Guardrail",description:"Connections between Deterministic and Stochastic Samplers",section:"Posts",handler:()=>{window.location.href="/blog/2024/samplers/"}},{id:"post-all-flows-are-one-flow",title:"All Flows are One Flow",description:"Affine Interpolations Result in Equivalent Rectified Flows",section:"Posts",handler:()=>{window.location.href="/blog/2024/interpolation/"}},{id:"post-rectified-flow-an-introduction",title:"Rectified Flow, An Introduction",description:"A Brief Introduction to the Rectified Flow Model",section:"Posts",handler:()=>{window.location.href="/blog/2024/intro/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%72%65%63%74%69%66%69%65%64%66%6C%6F%77@%67%6F%6F%67%6C%65%67%72%6F%75%70%73.%63%6F%6D","_blank")}},{id:"socials-google-scholar",title:"Google Scholar",section:"Socials",handler:()=>{window.open("https://scholar.google.com/citations?user=XEx1fZkAAAAJ","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>