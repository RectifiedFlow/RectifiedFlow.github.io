<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> All Flows are One Flow | Rectified Flow </title> <meta name="author" content="Rectified Flow "> <meta name="description" content="Affine Interpolations Result in Equivalent Rectified Flows"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://rectifiedflow.github.io/blog/2024/interpolation/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.min.css" integrity="sha256-q9ba7o845pMPFU+zcAll8rv+gC+fSovKsOoNQ6cynuQ=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github.min.css" integrity="sha256-Oppd74ucMR5a5Dq96FxjEzGF7tTw2fZ/6ksAqDCM8GY=" crossorigin="anonymous" media="screen and (prefers-color-scheme: light)"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github-dark.min.css" integrity="sha256-nyCNAiECsdDHrr/s2OQsp5l9XeY2ZJ0rMepjCT2AkBk=" crossorigin="anonymous" media="screen and (prefers-color-scheme: dark)"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/diff2html@3.4.47/bundles/css/diff2html.min.css" integrity="sha256-IMBK4VNZp0ivwefSn51bswdsrhk0HoMTLc2GqFHFBXg=" crossorigin="anonymous"> <link defer rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css"> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/mermaid@10.7.0/dist/mermaid.min.js" integrity="sha256-TtLOdUA8mstPoO6sGvHIGx2ceXrrX4KgIItO06XOn8A=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js" integrity="sha256-1rA678n2xEx7x4cTZ5x4wpUCj6kUMZEZ5cxLSVSFWxw=" crossorigin="anonymous"></script> <script>let mermaidTheme=determineComputedTheme();document.addEventListener("readystatechange",()=>{"complete"===document.readyState&&(document.querySelectorAll("pre>code.language-mermaid").forEach(e=>{const t=e.textContent,d=e.parentElement;d.classList.add("unloaded");let a=document.createElement("pre");a.classList.add("mermaid");const n=document.createTextNode(t);a.appendChild(n),d.after(a)}),mermaid.initialize({theme:mermaidTheme}),"undefined"!=typeof d3&&window.addEventListener("load",function(){d3.selectAll(".mermaid svg").each(function(){var e=d3.select(this);e.html("<g>"+e.html()+"</g>");var t=e.select("g"),d=d3.zoom().on("zoom",function(e){t.attr("transform",e.transform)});e.call(d)})}))});</script> <script src="https://cdn.jsdelivr.net/npm/diff2html@3.4.47/bundles/js/diff2html-ui.min.js" integrity="sha256-eU2TVHX633T1o/bTQp6iIJByYJEtZThhF9bKz/DcbbY=" crossorigin="anonymous"></script> <script>let diff2HtmlTheme=determineComputedTheme();document.addEventListener("readystatechange",()=>{"complete"===document.readyState&&document.querySelectorAll("pre>code.language-diff2html").forEach(e=>{const t=e.textContent,d=e.parentElement;d.classList.add("unloaded");let l=document.createElement("div");l.classList.add("diff2html"),d.after(l),new Diff2HtmlUI(l,t,{colorScheme:diff2HtmlTheme,drawFileList:!0,highlight:!0,matching:"lines"}).draw()})});</script> <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.min.js" integrity="sha256-MgH13bFTTNqsnuEoqNPBLDaqxjGH+lCpqrukmXc8Ppg=" crossorigin="anonymous"></script> <script>document.addEventListener("readystatechange",()=>{"complete"===document.readyState&&document.querySelectorAll("pre>code.language-geojson").forEach(e=>{const t=e.textContent,a=e.parentElement;a.classList.add("unloaded");let o=document.createElement("div");o.classList.add("map"),a.after(o);var n=L.map(o);L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png",{maxZoom:19,attribution:'&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'}).addTo(n);let d=L.geoJSON(JSON.parse(t)).addTo(n);n.fitBounds(d.getBounds())})});</script> <script defer src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js" integrity="sha256-0q+JdOlScWOHcunpUk21uab1jW7C1deBQARHtKMcaB4=" crossorigin="anonymous"></script> <script>$(document).ready(function(){var t=null,a=null,e=null,n="";$(".language-chartjs").each(function(){a=$(this),t=$("<canvas></canvas>"),n=a.text(),a.text("").append(t),(e=t.get(0).getContext("2d"))&&n&&new Chart(e,JSON.parse(n))&&a.attr("data-processed",!0)})});</script> <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js" integrity="sha256-QvgynZibb2U53SsVu98NggJXYqwRL7tg3FeyfXvPOUY=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/theme/dark-fresh-cut.js" integrity="sha256-sm6Ui9w41++ZCWmIWDLC18a6ki72FQpWDiYTDxEPXwU=" crossorigin="anonymous"></script> <script>let echartsTheme=determineComputedTheme();document.addEventListener("readystatechange",()=>{"complete"===document.readyState&&document.querySelectorAll("pre>code.language-echarts").forEach(e=>{const t=e.textContent,a=e.parentElement;a.classList.add("unloaded");let r=document.createElement("div");if(r.classList.add("echarts"),a.after(r),"dark"===echartsTheme)var n=echarts.init(r,"dark-fresh-cut");else n=echarts.init(r);n.setOption(JSON.parse(t)),window.addEventListener("resize",function(){n.resize()})})});</script> <script defer src="https://cdn.jsdelivr.net/npm/vega@5.27.0/build/vega.min.js" integrity="sha256-Yot/cfgMMMpFwkp/5azR20Tfkt24PFqQ6IQS+80HIZs=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/vega-lite@5.16.3/build/vega-lite.min.js" integrity="sha256-TvBvIS5jUN4BSy009usRjNzjI1qRrHPYv7xVLJyjUyw=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/vega-embed@6.24.0/build/vega-embed.min.js" integrity="sha256-FPCJ9JYCC9AZSpvC/t/wHBX7ybueZhIqOMjpWqfl3DU=" crossorigin="anonymous"></script> <script>let vegaTheme=determineComputedTheme();document.addEventListener("readystatechange",()=>{"complete"===document.readyState&&document.querySelectorAll("pre>code.language-vega_lite").forEach(e=>{const t=e.textContent,a=e.parentElement;a.classList.add("unloaded");let d=document.createElement("div");d.classList.add("vega-lite"),a.after(d),"dark"===vegaTheme?vegaEmbed(d,JSON.parse(t),{theme:"dark"}):vegaEmbed(d,JSON.parse(t))})});</script> <script defer src="https://tikzjax.com/v1/tikzjax.js" integrity="sha256-+1qyucCXRZJrCg3lm3KxRt/7WXaYhBid4/1XJRHGB1E=" crossorigin="anonymous"></script> <script src="/assets/js/typograms.js?63f3caa50c7a9624f953b3aec207afa6"></script> <script>document.addEventListener("readystatechange",()=>{"complete"===document.readyState&&document.querySelectorAll("pre>code.language-typograms").forEach(e=>{const t=e.textContent,n=e.parentElement.parentElement;let a=document.createElement("pre");a.classList.add("typogram");const d=create("\n"+t,.3,!1);a.appendChild(d),n.appendChild(a),n.removeChild(e.parentElement)})});</script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "All Flows are One Flow",
            "description": "Affine Interpolations Result in Equivalent Rectified Flows",
            "published": "December 10, 2024",
            "authors": [
              
              {
                "author": "Runlong Liao",
                "authorURL": "mailto:rectifiedflow@googlegroups.com",
                "affiliations": [
                  {
                    "name": "UT Austin",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Xixi Hu",
                "authorURL": "",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Bo Liu",
                "authorURL": "",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Qiang Liu",
                "authorURL": "",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              }
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Rectified Flow</span> </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>All Flows are One Flow</h1> <p>Affine Interpolations Result in Equivalent Rectified Flows</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#point-wisely-transformable-interpolations">Point-wisely Transformable Interpolations</a> </div> <ul> <li> <a href="#equivalence-of-affine-interpolations">Equivalence of Affine Interpolations</a> </li> <li> <a href="#converting-pretrained-rf-velocity">Converting Pretrained RF Velocity</a> </li> </ul> <div> <a href="#implications-on-loss-functions">Implications on Loss Functions</a> </div> <ul> <li> <a href="#straight-vs-spherical-same-train-time-weight">Straight vs Spherical: Same Train Time Weight</a> </li> </ul> </nav> </d-contents> <div class="hero"> <img src="/assets/img/teaser_post2.png" alt="Rectified Flow Overview" style="width: 100%; max-height: 500px; object-fit: cover; border-radius: 10px; margin-bottom: 20px;"> </div> <p>This blog introduces the equivalent relationships between rectified flows induced from different affine interpolations, based on Chapter 3 of these <a href="https://github.com/lqiang67/rectified-flow/tree/main/pdf" rel="external nofollow noopener" target="_blank">lecture notes</a>. Related observations and discussion can also be found in <d-cite key="karras2022elucidating,kingma2024understanding,shaulbespoke,gao2025diffusionmeetsflow"></d-cite>.</p> <h2 id="overview">Overview</h2> <p>Given an arbitrary coupling \((X_0, X_1)\) of source distribution \(X_0\sim \pi_0\) and target unknown data distribution \(X_1 \sim \pi_1\), recall that rectified flow learns a ODE</p> \[\mathrm d Z_t = v_t(Z_t) \mathrm d t,\] <p>which, starts from the noise \(Z_0=X_0\), leads to generated data \(Z_1\). This velocity is learned by minimizing the mean square loss from the slope of an interpolation process:</p> \[\min_v \int _0 ^1 \mathbb E \left[\left\| \dot X_t - v_t(X_t)\right\|^2 \right] \mathrm d t,\] <p>where \(\{X_t\} = \{X_t: t\in [0,1]\}\) is an interpolation process connecting \(X_0\) and \(X_1\), and \(\dot X_t\) denotes its time derivative.</p> <p>Theoretically, \(\{X_t\}\) can be any smooth interpolation between source and target distributions. Here, we go over three types of interpolations:</p> <ol> <li> <p><em>Straight interpolation</em>, as used in <d-cite key="liu2022flow,lipman2022flow,albergo2023stochastic"></d-cite>:</p> \[X_t = tX_1 + (1-t) X_0.\] <p>This yields straight lines connecting \(\pi_0\) and \(\pi_1\) at a constant speed \(\dot X_t = X_1 - X_0.\)</p> </li> <li> <p><em>Spherical linear interpolation</em> (<em>slerp</em>), employed by iDDPM <d-cite key="nichol2021improved"></d-cite>:</p> \[X_t = \sin\left(\frac{\pi}{2} t\right)X_1 + \cos\left(\frac{\pi}{2} t\right)X_0,\] <p>which travels along the shortest great-circle arc on a sphere at a constant speed.</p> </li> <li> <p><em>DDIM interpolation</em>,<d-cite key="song2020denoising"></d-cite> a spherical interpolation satisfying \(\alpha_t^2 + \beta_^2 = 1\) but with a non-uniform speed defined by $\alpha_t$:</p> \[X_t = \alpha_t X_1 + \sqrt{1-\alpha_t^2} X_0,\] <p>where \(\alpha_t = \exp\bigl(-\frac{1}{4}a(1-t)^2 - \tfrac{1}{2}b(1-t)\bigr)\), and \(a=19.9,b=0.1\) by default.</p> </li> </ol> <p>Different methods employ these or other interpolation schemes. One might suspect that such choices, by influencing the learned RF velocity, must be finalized during training, because the velocity field could significantly affect inference performance and speed. However, this need not be the case.</p> <p>In this blog, we show that if two interpolation processes are pointwise transformable in a suitable sense, then they would induce essentially <em>equivalent</em> rectified flow dynamics and identical couplings. In particular, all affine interpolations are pointwise transformable to one other. Thus, it suffices to adopt a simple interpolation, such as the straight line \(X_t = t X_1 + (1-t) X_0\), and later recover all affine interpolation through simple transformations. This flexibility shifts our attention to the sampling stage, where different interpolation schemes can be freely adopted, while their differences remain relatively minor during training.</p> <h2 id="point-wisely-transformable-interpolations">Point-wisely Transformable Interpolations</h2> <p>Let us start with a general notion of pointwise transformability between interpolation processes.</p> <blockquote> <p><strong>Definition 1</strong>. Consider any two interpolation processes \(\{X_t : t \in [0,1]\}\) and \(\{X'_t : t \in [0,1]\}\). We say they are <strong>pointwise transformable</strong> if there exist differentiable maps \(\tau: [0,1] \to [0,1]\) and \(\phi: [0,1] \times \mathbb{R}^d \to \mathbb{R}^d\) such that \(\phi_t\) is invertible for every \(t \in [0,1]\) and</p> \[X'_t = \phi_t(X_{\tau_t}) \quad \text{for all } t \in [0,1].\] </blockquote> <p>If two interpolations are pointwise transformable, then the trajectories of their respective rectified flows satisfy the very same transform. In addition, if the two interpolations are constructed from the same coupling, they yields the same recitifed coupling theoretically.</p> <blockquote> <p><strong>Theorem 1</strong>. Suppose two interpolations \(\{X_t\}\) and \(\{X'_t\}\) are pointwise transformable and constructed from the same coupling \((X_0, X_1) = (X'_0, X'_1)\). Assume \(\tau_0=0\) and \(\tau_1=1\).</p> <p>Let \(\{v_t\}\) and \(\{v'_t\}\) be their corresponding Rectified Flow velocity fields, and \(\{Z_t\}\) and \(\{Z'_t\}\) their Rectified Flows with \(\mathrm d Z_t = v_t(Z_t)\mathrm d t\), \(Z_0 = X_0\), and \(\mathrm d Z'_t = v'_t(Z'_t)\mathrm d t\), \(Z'_0=X'_0\), respectively.</p> <p>Then</p> <ol> <li> <p>The recitied rlows \(\{Z_t\}\to\{Z'_t\}\) can be transformed with the very same pointwise maps:</p> \[Z'_t = \phi_t(Z_{\tau_t}) \quad \text{for all } t \in [0,1].\] </li> <li> <p>The two rectified flows produce the rectified coupling:</p> \[(Z_0, Z_1) = (Z'_0, Z'_1).\] </li> <li> <p>Their velocity fields are related by:</p> \[v'_t(x) = \partial_t \phi_t(\phi_t^{-1}(x)) + \bigl(\nabla \phi_t(\phi_t^{-1}(x))\bigr)^\top v_{\tau_t}(\phi_t^{-1}(x)) \dot{\tau}_t. \tag{1}\] </li> </ol> </blockquote> <p>In other words, denote by \(\{X'_t\} := \texttt{Transform}(\{X_t\})\) a pointwise transformation on the interpolations. Then the result shows that the operation \(\texttt{Rectify}(\cdot)\), which maps an interpolation \(\{X_t\}\) to its corresponding rectified flow \(\{Z_t\}\), is <strong>equivariant</strong> under pointwise transformations:</p> \[\texttt{Rectify}(\texttt{Transform}(\{X_t\})) = \texttt{Transform}(\texttt{Rectify}(\{X_t\})).\] <h3 id="affine-interpolations-are-pointwise-transformable">Affine Interpolations are Pointwise Transformable</h3> <p>In practice, one often considers interpolations of the form</p> \[X_t = \alpha_t X_1 + \beta_t X_0,\] <p>where $\alpha_t$ and $\beta_t$ are monotonic on $t\in[0,1]$ and satisfy the boundary conditions:</p> \[\alpha_0=\beta_1=0, \quad \alpha_1 = \beta_0 = 1.\] <p>All such interpolations are <em>affine</em>. For this class of interpolations, the transformation maps \(\phi\) and \(\tau\) reduce to scalar transformations. In fact, <strong>all affine interpolations are pointwise transformable</strong> by appropriately scaling both time and the input. Consequently, their corresponding rectified flows can also be related through the same pointwise transformations, ultimately producing the same rectified couplings. This result aligns with observations made by other authors<d-cite key="karras2022elucidating,kingma2024understanding,shaulbespoke,gao2025diffusionmeetsflow"></d-cite>.</p> <blockquote> <p><strong>Proposition 1</strong>. Consider two affine interpolation processes derived from the same coupling \((X_0, X_1)\): \(X_t = \alpha_t X_1 + \beta_t X_0 \quad \text{and} \quad X_t' = \alpha_t' X_1 + \beta_t' X_0.\)</p> <p>Then there exist scalar functions \(\tau_t\) and \(\omega_t\) such that</p> \[X_t' = \frac{1}{\omega_t} X_{\tau_t}, \quad \forall t \in [0,1],\] <p>where \(\tau_t\) and \(\omega_t\) are determined by solving</p> \[\frac{\alpha_{\tau_t}}{\beta_{\tau_t}} = \frac{\alpha'_t}{\beta'_t}, \quad \omega_t = \frac{\alpha_{\tau_t}}{\alpha'_t} = \frac{\beta_{\tau_t}}{\beta'_t}, \quad \forall t \in (0, 1) \tag{2}\] <p>under the boundary conditions</p> \[\omega_0 = \omega_1 = 1, \quad \tau_0 = 0, \quad \tau_1 = 1.\] <p>The solution of \((\tau_t, \omega_t)\) exists and is unique if \(\alpha'_t/\beta'_t \geq 0\) and \(\alpha_t/\beta_t\) is continuous and strictly increasing for \(t \in [0,1]\).</p> </blockquote> <p>In practice, the equation regarding \(\tau_t\) can be solved with a <a href="https://github.com/lqiang67/rectified-flow/blob/main/rectified_flow/flow_components/interpolation_convertor.py" rel="external nofollow noopener" target="_blank">simple binary search</a>. In some simple cases, the solution can be derived analytically.</p> <p>The figure below illustrates the \(\tau\) and \(\phi\) transformations that convert DDIM to spherical interpolation, and straight interpolation to spherical. Note that when converting DDIM to spherical interpolation, the only difference is in the time scaling—\(\omega_t\) remains constant at \(1\).</p> <div class="l-body-outset" style="display: flex;"> <iframe src="/assets/plotly/interp_tau_ddim_spherical.html" frameborder="0" scrolling="no" height="430px" width="49%"></iframe> <iframe src="/assets/plotly/interp_tau_straight_spherical.html" frameborder="0" scrolling="no" height="430px" width="49%"></iframe> </div> <p>Combining Proposition 1 with Theorem 1, we have:</p> <blockquote> <p><strong>Proposition 2</strong>. Assume \(\{X_t\}\) and \(\{X'_t\}\) are two affine interpolations:</p> <ul> <li>Their respective rectified flows \(\{Z_t\}\) and \(\{Z'_t\}\) satisfy:</li> </ul> \[Z'_t = \omega_t^{-1} Z_{\tau_t}, \quad \forall t \in [0, 1].\] <ul> <li>Their rectified couplings are equivalent:</li> </ul> \[(Z_0, Z_1) = (Z'_0, Z'_1).\] <ul> <li>Their RF velocity fields \(v_t\) and \(v'_t\) satisfy:</li> </ul> \[v'_t(x) = \frac{1}{\omega_t} \left( \dot{\tau}_t v_{\tau_t}(\omega_t x) - \dot{\omega}_t x \right). \tag{3}\] </blockquote> <blockquote> <p><strong>Example 1.</strong> Converting straight interpolation into affine ones.</p> <p>Consider the straight interpolation \(X_t=tX_1 + (1-t)X_0\) with \(\alpha_t=t\) and \(\beta_t=1-t\). We seek to transform it into another affine interpolation \(X'_t = \alpha'_t X_1 + \beta'_t X_0.\) Solving the equations</p> \[\omega_t = \frac{\tau_t}{\alpha'_t} = \frac{1-\tau_t}{\beta'_t}\] <p>yields</p> \[\tau_t = \frac{\alpha'_t}{\alpha'_t + \beta_t'}, \quad \omega_t = \frac{1}{\alpha_t' + \beta_t'}\] <p>Substituting these into the velocity fields, we have</p> \[v'_t(x) = \frac{\dot{\alpha}'_t \beta'_t - \alpha'_t \dot{\beta}'_t}{\alpha'_t + \beta'_t} v_{\tau_t}(\omega_t x) \;+\; \frac{\dot{\alpha}'_t + \dot{\beta}'_t}{\alpha'_t + \beta'_t} x.\] </blockquote> <div class="l-body-outset"> <iframe src="/assets/plotly/interp_convert_200step.html" frameborder="0" scrolling="no" height="630px" width="100%"></iframe> </div> <p>In the figure above, we start with a pretrained RF model that uses a straight interpolation and convert it into a spherical RF. We then apply Euler sampling to both RFs. Although the two RFs follow entirely different trajectories, they both reach the same endpoint \(Z_1\), and hence the same rectified coupling.</p> <div class="l-body-outset"> <iframe src="/assets/plotly/interp_convert_10step.html" frameborder="0" scrolling="no" height="630px" width="100%"></iframe> </div> <p>However, as the number of sampling steps decreases to as few as \(10\), the endpoints \(Z_1\) and \(Z_1'\) begin to diverge, the diffences between them becomes more pronounced with fewer steps. This indicates that, although different affine interpolation schemes theoretically produce the same rectified coupling \((Z_0, Z_1)\), their intermediate trajectories \(\{Z_t\}\) are not the same. When solving the ODEs, discretization errors accumulate along these trajectories. <strong>Straighter trajectories are generally preferable</strong> because they tend to reduce discretization errors and yield more accurate results.</p> <p>Owing to the transformation relationships described above, it is possible to change the interpolation scheme of a pretrained model without retraining. This approach allows one to select a scheme that produces straighter trajectories \(\{Z_t\}\), thus improving the performance of sampling.</p> <h2 id="implications-on-loss-functions">Implications on Loss Functions</h2> <p>Assume that we have trained a paramtric model \(v_t(x;\theta)\) for the RF velocity field \(v_t(x)\) under an affine interpolation. Using the formulas from the previous section, we can convert it to a model \(v'_t(x, \theta)\) for \(v'_t(x)\) corresponding to a different interpolation scheme at the post-training stage.</p> <p>This raises the question of what properties the converted model \(\hat{v}'_t\) may have compared to the models trained directly on the same interpolation, and whether it suffers from performance degradation due to the conversion.</p> <p>It turns out that using different affine interpolation schemes during training is equivalent to applying <strong>different time-weighting</strong> in the loss function, as well as an affine transform on the parametric model. Unless \(\omega_t\) and \(\tau_t\) are highly singular, the conversion does not necessarily degrade performance.</p> <p>Specifically, assume we have trained a parametric model \(v_t(x; \theta)\) to approximate the RF velocity \(v_t\) of interpolation \(X_t = \alpha_t X_1 + \beta_t X_0\), using the mean square loss:</p> \[\mathcal L(\theta) = \int_0^1 \mathbb E\left[ \eta_t \left \| \dot X_t - v_t(X_t;\theta)\right\|^2 \right] \mathrm dt \tag{4}\] <p>After training, we may convert the obtained model \(v_t(x; \theta)\) to an approximation of \(v'_t\) of a different interpolation \(X'_t = \alpha_t' X_1 + \beta_t' X_0\) via:</p> \[v'_t(x; \theta) = \frac{\dot{\tau}_t}{\omega_t} v_{\tau_t}(\omega_t x; \theta) - \frac{\dot{\omega}_t}{\omega_t} x,\] <p>On the other hand, if we train \(v'_t(x; \theta)\) directly to approximate \(v'_t\) of interpolation \(X'_t = \alpha'_t X_1 + \beta'_t X_0\), the loss function is:</p> \[\mathcal L'(\theta) = \int_0^1 \mathbb{E} \left[ \eta'_t \left\| \dot{X}'_t - v'_t(X'_t; \theta) \right\|^2 \right] \mathrm dt \tag{5}\] <p>By matching the loss \((4)\) and \((5)\), derivations show that these two training schemes are identical, except for the following time-weighting and reparametrization relationship:</p> \[\eta'_t = \frac{\omega_t^2}{\dot{\tau}_t} \eta_{\tau_t}, \quad v'_t(x; \theta) = \frac{\dot{\tau}_t}{\omega_t} v_{\tau_t}(\omega_t x; \theta) - \frac{\dot{\omega}_t}{\omega_t} x. \tag{6}\] <p>In other words, <strong>training with different interpolation schemes simply only introduces different training time weights and model parameterizations.</strong></p> <blockquote> <p><strong>Example 2. Loss from Straight to Affine</strong></p> <p>Consider the straight interpolation \(X_t = t X_1 + (1 - t) X_0\) with \(\alpha_t = t\) and \(\beta_t = 1 - t\), alongside another affine interpolation \(X_t' = \alpha_t' X_1 + \beta_t' X_0\).</p> <p>Suppose we have trained the \(v_t\) for \(X_t\) with a time weight \(\eta_t\), then \(v_t'\) converted from \(v_t\) is equivalent to the RF trained with the parametrization in \((6)\), and another time weight:</p> \[\eta_t' = \frac{\omega_t^2}{\tau_t'} \eta_{\tau_t} = \frac{1}{\dot{\alpha}_t' \beta_t' - \alpha_t' \dot{\beta}_t'} \eta_{\tau_t},\] <p>Here, we substitute the relationships derived in Example 1 into \((6)\).</p> </blockquote> <h3 id="straight-vs-spherical-same-train-time-weight">Straight vs Spherical: Same Train Time Weight</h3> <blockquote> <p><strong>Example 3.</strong> Losses for Straight vs. Spherical Interpolation Following Example 2, an interesting case is when \(\dot \alpha_t' \beta_t' - \alpha_t \beta_t' = \text{const},\) with which we have \(\eta_t' \propto \eta_{\tau_t}\). Moreover, if $\eta_t = 1$ is uniform, then $\eta_t’$ is also uniform, meaning that the two interpolations share the same loss function.</p> <p>This happens to the spherical interpolation \(X'_t = \sin\left(\frac{\pi t}{2}\right)X_1 + \cos\left(\frac{\pi t}{2}\right)X_0,\) for which we have \(\dot \alpha_t' \beta_t' - \alpha_t \beta_t' = \frac{\pi}{2}\) and hence</p> \[\eta'_t = \frac{2}{\pi} \eta_{\tau_t}, \quad \tau_t = \frac{\tan\left(\frac{\pi }{2} t \right)}{\tan\left(\frac{\pi }{2}t\right)+1}.\] <p>In this case, training \(v_t\) with the straight interpolation using a uniform weight \(\eta_t = 1\) is equivalent to training \(v'_t\) with the spherical interpolation, also with a uniform weight \(\eta'_t = 2 /\pi\). The sole difference is a reparameterization of the model:</p> \[v'_t(x, \theta) = \frac{\pi \omega_t}{2} \left( v_{\tau_t}(\omega_t x; \theta) + \left( \cos\left(\frac{\pi t}{2}\right) - \sin\left(\frac{\pi t}{2}\right) \right) x \right),\] <p>where \(\omega_t = (\sin(\frac{\pi t}{2}) + \cos(\frac{\pi t}{2}))^{-1}\) is bounded within \([1/\sqrt{2}, 1]\). This reparameterization does not significantly influence performance. As we’ll see in practice, choosing between straight or spherical interpolation makes <strong>little difference</strong> in training outcomes.</p> </blockquote> <div class="l-body-outset"> <iframe src="/assets/plotly/interp_convert_double_rf.html" frameborder="0" scrolling="no" height="630px" width="100%"></iframe> </div> <p>In the figure above, we compare two RF models: one trained with straight interpolation and another with spherical interpolation. We then convert the straight RF into the spherical one. As Example 3 suggests, we can see that the two trajectories are nearly identical, except for minor divergence near \(t=1\) due to accumulated numerical errors.</p> <div class="l-body-outset"> <iframe src="/assets/plotly/interp_match_time_weight.html" frameborder="0" scrolling="no" height="630px" width="100%"></iframe> </div> <p>In this figure, we reparameterize the straight RF into \(v'_t\) and train it with spherical interpolation. This time, we find that the resulting trajectories align almost perfectl, since the weight and parametrization match exactly.</p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/2024-12-10-interpolation.bib"></d-bibliography> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Rectified Flow . Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-about",title:"about",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-blog",title:"blog",description:"",section:"Navigation",handler:()=>{window.location.href="/blog/"}},{id:"post-natural-euler-samplers",title:"Natural Euler Samplers",description:"A Pointwise-Transformable Discretization of Flows",section:"Posts",handler:()=>{window.location.href="/blog/2024/discretization/"}},{id:"post-stochastic-sampler-langevin-as-guardrail",title:"Stochastic Sampler: Langevin as Guardrail",description:"Connections between Deterministic and Stochastic Samplers",section:"Posts",handler:()=>{window.location.href="/blog/2024/samplers/"}},{id:"post-all-flows-are-one-flow",title:"All Flows are One Flow",description:"Affine Interpolations Result in Equivalent Rectified Flows",section:"Posts",handler:()=>{window.location.href="/blog/2024/interpolation/"}},{id:"post-rectified-flow-an-introduction",title:"Rectified Flow: An Introduction",description:"A First Introduction to Rectified Flow",section:"Posts",handler:()=>{window.location.href="/blog/2024/intro/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%72%65%63%74%69%66%69%65%64%66%6C%6F%77@%67%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"socials-google-scholar",title:"Google Scholar",section:"Socials",handler:()=>{window.open("https://scholar.google.com/citations?user=XEx1fZkAAAAJ","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>