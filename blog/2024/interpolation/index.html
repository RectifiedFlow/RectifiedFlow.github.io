<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Interpolations: All Flows are One Flow | Let us Flow Together ‡ºÑ‡øê‡øîüöÄ </title> <meta name="author" content="Rectified Flow "> <meta name="description" content="Various interpolation schemes have been suggested in different methods. How do they impact performance? Is the simplest straight-line interpolation enough?"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://rectifiedflow.github.io/blog/2024/interpolation/"> <script src="/assets/js/theme.js?d20a716699d1917d2b31cd9a0d140d86"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.min.css" integrity="sha256-q9ba7o845pMPFU+zcAll8rv+gC+fSovKsOoNQ6cynuQ=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github.min.css" integrity="sha256-Oppd74ucMR5a5Dq96FxjEzGF7tTw2fZ/6ksAqDCM8GY=" crossorigin="anonymous" media="screen and (prefers-color-scheme: light)"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github-dark.min.css" integrity="sha256-nyCNAiECsdDHrr/s2OQsp5l9XeY2ZJ0rMepjCT2AkBk=" crossorigin="anonymous" media="screen and (prefers-color-scheme: dark)"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/diff2html@3.4.47/bundles/css/diff2html.min.css" integrity="sha256-IMBK4VNZp0ivwefSn51bswdsrhk0HoMTLc2GqFHFBXg=" crossorigin="anonymous"> <link defer rel="stylesheet" type="text/css" href="https://tikzjax.com/v1/fonts.css"> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/mermaid@10.7.0/dist/mermaid.min.js" integrity="sha256-TtLOdUA8mstPoO6sGvHIGx2ceXrrX4KgIItO06XOn8A=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js" integrity="sha256-1rA678n2xEx7x4cTZ5x4wpUCj6kUMZEZ5cxLSVSFWxw=" crossorigin="anonymous"></script> <script>let mermaidTheme=determineComputedTheme();document.addEventListener("readystatechange",()=>{"complete"===document.readyState&&(document.querySelectorAll("pre>code.language-mermaid").forEach(e=>{const t=e.textContent,d=e.parentElement;d.classList.add("unloaded");let a=document.createElement("pre");a.classList.add("mermaid");const n=document.createTextNode(t);a.appendChild(n),d.after(a)}),mermaid.initialize({theme:mermaidTheme}),"undefined"!=typeof d3&&window.addEventListener("load",function(){d3.selectAll(".mermaid svg").each(function(){var e=d3.select(this);e.html("<g>"+e.html()+"</g>");var t=e.select("g"),d=d3.zoom().on("zoom",function(e){t.attr("transform",e.transform)});e.call(d)})}))});</script> <script src="https://cdn.jsdelivr.net/npm/diff2html@3.4.47/bundles/js/diff2html-ui.min.js" integrity="sha256-eU2TVHX633T1o/bTQp6iIJByYJEtZThhF9bKz/DcbbY=" crossorigin="anonymous"></script> <script>let diff2HtmlTheme=determineComputedTheme();document.addEventListener("readystatechange",()=>{"complete"===document.readyState&&document.querySelectorAll("pre>code.language-diff2html").forEach(e=>{const t=e.textContent,d=e.parentElement;d.classList.add("unloaded");let l=document.createElement("div");l.classList.add("diff2html"),d.after(l),new Diff2HtmlUI(l,t,{colorScheme:diff2HtmlTheme,drawFileList:!0,highlight:!0,matching:"lines"}).draw()})});</script> <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.min.js" integrity="sha256-MgH13bFTTNqsnuEoqNPBLDaqxjGH+lCpqrukmXc8Ppg=" crossorigin="anonymous"></script> <script>document.addEventListener("readystatechange",()=>{"complete"===document.readyState&&document.querySelectorAll("pre>code.language-geojson").forEach(e=>{const t=e.textContent,a=e.parentElement;a.classList.add("unloaded");let o=document.createElement("div");o.classList.add("map"),a.after(o);var n=L.map(o);L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png",{maxZoom:19,attribution:'&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'}).addTo(n);let d=L.geoJSON(JSON.parse(t)).addTo(n);n.fitBounds(d.getBounds())})});</script> <script defer src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js" integrity="sha256-0q+JdOlScWOHcunpUk21uab1jW7C1deBQARHtKMcaB4=" crossorigin="anonymous"></script> <script>$(document).ready(function(){var t=null,a=null,e=null,n="";$(".language-chartjs").each(function(){a=$(this),t=$("<canvas></canvas>"),n=a.text(),a.text("").append(t),(e=t.get(0).getContext("2d"))&&n&&new Chart(e,JSON.parse(n))&&a.attr("data-processed",!0)})});</script> <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js" integrity="sha256-QvgynZibb2U53SsVu98NggJXYqwRL7tg3FeyfXvPOUY=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/theme/dark-fresh-cut.js" integrity="sha256-sm6Ui9w41++ZCWmIWDLC18a6ki72FQpWDiYTDxEPXwU=" crossorigin="anonymous"></script> <script>let echartsTheme=determineComputedTheme();document.addEventListener("readystatechange",()=>{"complete"===document.readyState&&document.querySelectorAll("pre>code.language-echarts").forEach(e=>{const t=e.textContent,a=e.parentElement;a.classList.add("unloaded");let r=document.createElement("div");if(r.classList.add("echarts"),a.after(r),"dark"===echartsTheme)var n=echarts.init(r,"dark-fresh-cut");else n=echarts.init(r);n.setOption(JSON.parse(t)),window.addEventListener("resize",function(){n.resize()})})});</script> <script defer src="https://cdn.jsdelivr.net/npm/vega@5.27.0/build/vega.min.js" integrity="sha256-Yot/cfgMMMpFwkp/5azR20Tfkt24PFqQ6IQS+80HIZs=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/vega-lite@5.16.3/build/vega-lite.min.js" integrity="sha256-TvBvIS5jUN4BSy009usRjNzjI1qRrHPYv7xVLJyjUyw=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/vega-embed@6.24.0/build/vega-embed.min.js" integrity="sha256-FPCJ9JYCC9AZSpvC/t/wHBX7ybueZhIqOMjpWqfl3DU=" crossorigin="anonymous"></script> <script>let vegaTheme=determineComputedTheme();document.addEventListener("readystatechange",()=>{"complete"===document.readyState&&document.querySelectorAll("pre>code.language-vega_lite").forEach(e=>{const t=e.textContent,a=e.parentElement;a.classList.add("unloaded");let d=document.createElement("div");d.classList.add("vega-lite"),a.after(d),"dark"===vegaTheme?vegaEmbed(d,JSON.parse(t),{theme:"dark"}):vegaEmbed(d,JSON.parse(t))})});</script> <script defer src="https://tikzjax.com/v1/tikzjax.js" integrity="sha256-+1qyucCXRZJrCg3lm3KxRt/7WXaYhBid4/1XJRHGB1E=" crossorigin="anonymous"></script> <script src="/assets/js/typograms.js?63f3caa50c7a9624f953b3aec207afa6"></script> <script>document.addEventListener("readystatechange",()=>{"complete"===document.readyState&&document.querySelectorAll("pre>code.language-typograms").forEach(e=>{const t=e.textContent,n=e.parentElement.parentElement;let a=document.createElement("pre");a.classList.add("typogram");const d=create("\n"+t,.3,!1);a.appendChild(d),n.appendChild(a),n.removeChild(e.parentElement)})});</script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <script src="/assets/js/distillpub/overrides.js"></script> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "Interpolations: All Flows are One Flow",
            "description": "Various interpolation schemes have been suggested in different methods. How do they impact performance? Is the simplest straight-line interpolation enough?",
            "published": "December 10, 2024",
            "authors": [
              
              {
                "author": "Runlong Liao",
                "authorURL": "",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Xixi Hu",
                "authorURL": "",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Bo Liu",
                "authorURL": "",
                "affiliations": [
                  {
                    "name": "",
                    "url": ""
                  }
                ]
              },
              
              {
                "author": "Qiang Liu",
                "authorURL": "mailto:rectifiedflow@gmail.com",
                "affiliations": [
                  {
                    "name": "UT Austin",
                    "url": ""
                  }
                ]
              }
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Let us Flow Together ‡ºÑ‡øê‡øîüöÄ </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/"> </a> </li> <li class="nav-item active"> <a class="nav-link" href="/index.html">Home </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Interpolations: All Flows are One Flow</h1> <p>Various interpolation schemes have been suggested in different methods. How do they impact performance? Is the simplest straight-line interpolation enough?</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#overview">Overview</a> </div> <div> <a href="#point-wisely-transformable-interpolations">Point-wisely Transformable Interpolations</a> </div> <ul> <li> <a href="#affine-interpolations-are-pointwise-transformable">Affine Interpolations are Pointwise Transformable</a> </li> </ul> <div> <a href="#implications-on-loss-functions">Implications on Loss Functions</a> </div> <ul> <li> <a href="#straight-vs-spherical-identical-train-time-weight">Straight vs Spherical: Identical Train Time Weight</a> </li> </ul> </nav> </d-contents> <p>Most diffusion and flow models can be analyzed through the rectified flow lens, but they employ different interpolation methods, typically affine interpolations such as straight-line or spherical interpolations. A critical question is to understand the impact of using different interpolation processes. This blog introduces the equivalent relationships between rectified flows induced by these different interpolation processes, as discussed in Chapter 3 of these <a href="https://github.com/lqiang67/rectified-flow/tree/main/pdf" rel="external nofollow noopener" target="_blank">lecture notes</a>. Related observations and discussions can also be found in <d-cite key="karras2022elucidating,kingma2024understanding,shaulbespoke,gao2025diffusionmeetsflow"></d-cite>.</p> <h2 id="overview">Overview</h2> <p>Given a coupling \((X_0, X_1)\) of the noise \(X_0 \sim \pi_0\) and data \(X_1 \sim \pi_1\), in rectified flow, we leverage an interpolation process \(X_t = \mathtt{I}_t(X_0, X_1)\), \(t \in [0,1]\), to smoothly connect \(X_0\) and \(X_1\), and then ‚Äúcausalize‚Äù or ‚Äúrectify‚Äù the interpolation \(\{X_t\}\) into its rectified flow \(\{Z_t\} = \mathtt{Rectify}(\{X_t\})\), an ODE-based generative model of the form:</p> \[\mathrm{d}Z_t = v_t(Z_t) \mathrm{d}t, \quad Z_0 = X_0, \quad \text{with velocity field} \quad v_t(x) = \mathbb{E}[\dot{X}_t \mid X_t = x],\] <p>where \(\dot{X}_t\) is the time derivative of \(X_t\). This formulation of \(v_t\) ensures that \(Z_t\) matches in distribution with \(X_t\) at every time \(t\). With this, we can generate data as \(Z_1\) by evolving forward in time from noise \(Z_0\).</p> <p>Intuitively, the rectified flow \(\{Z_t\}\) ‚Äúrewires‚Äù the trajectories of \(\{X_t\}\) at their intersection points to produce non-intersecting ODE trajectories. For further details, see <a href="https://arxiv.org/abs/2209.03003" rel="external nofollow noopener" target="_blank">paper</a><d-cite key="liu2022flow"></d-cite>, <a href="https://www.cs.utexas.edu/~lqiang/rectflow/html/intro.html" rel="external nofollow noopener" target="_blank">blog</a>, <a href="https://rectifiedflow.github.io/blog/2024/intro/" rel="external nofollow noopener" target="_blank">blog</a>.</p> <p>In principle, any time-differentiable interpolation process \(\{X_t\}\) that connects \(X_0\) and \(X_1\) can be used within this framework. Different methods employ different interpolation schemes. The simplest choice is the straight-line interpolation, defined as</p> \[X_t = t X_1 + (1-t) X_0,\] <p>which is naturally justified by optimal transport theory.</p> <p>Alternatively, other methods, such as DDIM and probability-flow ODEs, use curved interpolation schemes of a more general affine form:</p> \[X_t = \alpha_t X_1 + \beta_t X_0,\] <p>where \(\alpha_t\) and \(\beta_t\) are chosen in different ways depending on the method.</p> <p><strong>Questions:</strong> <em>What is the impact of the choice of interpolation? Do different interpolation schemes yield fundamentally different rectified flow dynamics?</em></p> <p>At first glance, it may appear that the interpolation process must be chosen during the training phase, as it directly affects the learned rectified flow. However, this is not necessarily the case.</p> <p>As it turns out, if two interpolation processes can be <strong>deformed</strong> into each other with a differentiable pointwise transform (i.e., they are diffeomorphic in mathy terms), then the trajectories of their rectified flows can also be deformed into each other using the very same transforms. In addition, if the two processes are constructed from the same couplings, then their rectified flows lead to the same rectified coupling \((Z_0, Z_1).\)</p> <p><em>Why is this true?</em> The intuition is illustrated in Figure 1. Recall that the trajectories of the rectified flow (RF) are simply a ‚Äúrewiring‚Äù of the interpolation trajectories at their intersection points to avoid crossings. As a result, the RF trajectories occupy the same ‚Äútrace‚Äù as the interpolation process. Consequently, any deformation applied to the interpolation process is inherited by the rectified flow.</p> <p>This is a general and fundamental property of the rectification process and is not restricted to specific distributions, couplings, or interpolations.</p> <figure id="figure-1" style="margin: 0 auto 1em auto;"> <div style="display: flex; justify-content: center;"> <img src="/assets/img/interpolation_conversion.gif" alt="interpolation conversion gif" style="max-width: 600px; height: auto;"> </div> <figcaption> <a href="#figure-1">Figure 1</a>. Pointwise transformable affine interpolations and their corresponding rectified flows. </figcaption> </figure> <p>Notably, any two affine interpolation processes are pointwise transformable through simple time and variable scaling. As a result, it is sufficient in principle to use the simplest straight-line interpolation during training, while recovering the rectified flow of all affine interpolations at inference time.</p> <p>The analytic relation enables us to analyze the impact of training and inference under different interpolations. For training, using different affine interpolations corresponds to applying time weightings in the training loss. We analyze this for the common straight-line and cosine interpolations and find that it appears to have limited impact on performance. For inference, using different interpolations corresponds to applying numerical discretization on transformed ODE trajectories, which is discussed in depth in this <a href="https://rectifiedflow.github.io/blog/2024/discretization/" rel="external nofollow noopener" target="_blank">blog</a>.</p> <h2 id="point-wisely-transformable-interpolations">Point-wisely Transformable Interpolations</h2> <p>We first formalize <em>pointwise transformability</em> between two interpolation processes.</p> <blockquote class="definition"> <p><strong>Definition 1.</strong> Let \(\{X_t : t \in [0,1]\}\) and \(\{X'_t : t \in [0,1]\}\) be two interpolations. They are <strong>pointwise transformable</strong> if there exist differentiable maps</p> \[\tau: [0,1] \to [0,1] \quad \text{ and } \quad \phi: [0,1] \times \mathbb{R}^d \to \mathbb{R}^d\] <p>such that each \(\phi_t\) is invertible, and</p> \[X'_t = \phi_t(X_{\tau_t}), \quad \forall t \in [0,1].\] </blockquote> <div class="l-gutter"> <img src="/assets/img/interpolation/interpolation.svg" style="max-width:100%;"> </div> <p>If two interpolations contructed from the same coupling \((X_0, X_1)\) and are pointwise transformable, then their rectified flows are also related by the <strong>same</strong> transform, and also lead to the same rectified coupling.</p> <blockquote class="theorem"> <p><strong>Theorem 1.</strong> Suppose \(\{X_t\}\) and \(\{X'_t\}\) constructed from the same coupling \((X_0, X_1) = (X'_0, X'_1)\) and are pointwise transformable. Assume \(\tau_0=0\) and \(\tau_1=1\).</p> <p>Denote by \(\{v_t\}\) and \(\{v'_t\}\) their rectified flow velocity fields. Let \(\{Z_t\}\) and \(\{Z'_t\}\) be their rectified flows with \(\mathrm d Z_t = v_t(Z_t)\mathrm d t,Z_0 = X_0\) and \(\mathrm d Z'_t = v'_t(Z'_t)\mathrm d t, Z'_0=X'_0.\) Then:</p> <ol> <li> <p>\(\{Z_t\},\{Z'_t\}\) can be transformed with the same pointwise maps:</p> \[Z'_t = \phi_t(Z_{\tau_t}) \quad \text{for all } t \in [0,1].\] </li> <li> <p>Their rectified couplings are the same: \((Z_0, Z_1) = (Z'_0, Z'_1).\)</p> </li> <li> <p>The velocity fields satisfy:</p> \[v'_t(x) = \partial_t \phi_t(\phi_t^{-1}(x)) + \bigl(\nabla \phi_t(\phi_t^{-1}(x))\bigr)^\top v_{\tau_t}(\phi_t^{-1}(x)) \dot{\tau}_t. \tag{1}\] </li> </ol> </blockquote> <p>This is equivalent to saying that the \(\texttt{Rectify}(\cdot)\) map is <strong>equivariant</strong> under the pointwise transforms \(\texttt{Transform}:\)</p> \[\texttt{Rectify}(\texttt{Transform}(\{X_t\})) = \texttt{Transform}(\texttt{Rectify}(\{X_t\})).\] <figure id="figure-1" style="margin: 0 auto 1em auto;"> <div style="display: flex; justify-content: center;"> <img src="/assets/img/interpolation_conversion_illustration.svg" alt="interpolation conversion illustration" style="max-width: 600px; height: auto;"> </div> </figure> <h3 id="affine-interpolations-are-pointwise-transformable">Affine Interpolations are Pointwise Transformable</h3> <p>Many commonly used interpolation schemes are affine $X_t = \alpha_t X_1 + \beta_t X_0,$ with \(\alpha_t\) and \(\beta_t\) are monotone, \(\alpha_0=\beta_1=0,\) and \(\alpha_1 = \beta_0 = 1.\) Examples include:</p> <ol> <li> <p><strong><em>Straight interpolation</em></strong> <d-cite key="liu2022flow,lipman2022flow,albergo2023stochastic"></d-cite>:</p> \[X_t = tX_1 + (1-t) X_0.\] <p>This yields straight lines connecting \(\pi_0\) and \(\pi_1\) at constant speed \(\dot X_t = X_1 - X_0.\)</p> </li> <li> <p><strong><em>Spherical linear interpolation</em></strong> (<em>slerp</em>) <d-cite key="nichol2021improved"></d-cite>:</p> \[X_t = \sin\left(\frac{\pi}{2} t\right)X_1 + \cos\left(\frac{\pi}{2} t\right)X_0,\] <p>which traces a shortest great-circle arc on a sphere at constant speed.</p> </li> <li> <p><strong><em>DDIM interpolation</em></strong> <d-cite key="song2020denoising"></d-cite> A spherical interpolation satisfying \(\alpha_t^2 + \beta_t^2 = 1\) but with a non-uniform speed defined by $\alpha_t$:</p> \[X_t = \alpha_t X_1 + \sqrt{1-\alpha_t^2} X_0,\] <p>where \(\alpha_t = \exp\bigl(-\frac{1}{4}a(1-t)^2 - \tfrac{1}{2}b(1-t)\bigr)\), and \(a=19.9,b=0.1\) by default.</p> </li> </ol> <p><strong>All affine interpolations are pointwise transformable by adjusting time and scaling</strong>. In this case, the maps \(\phi\) and \(\tau\) reduce to scalar transforms, as observed in a line of works <d-cite key="karras2022elucidating,kingma2024understanding,shaulbespoke,gao2025diffusionmeetsflow"></d-cite>. Hence, the rectified flows of all affine interpolations can be analytically transformed into one another, and they lead to the same rectified couplings.</p> <blockquote class="definition"> <p><strong>Proposition 1. Pointwise Transforms Between Affine Interpolations</strong></p> <p>Let \(X_t = \alpha_t X_1 + \beta_t X_0\) and \(X_t' = \alpha_t' X_1 + \beta_t' X_0\) be two affine interpolations from the same coupling \((X_0, X_1).\) Then there exist scalar functions \(\tau_t\) and \(\omega_t\) such that</p> \[X_t' = \frac{1}{\omega_t} X_{\tau_t}, \quad \forall t \in [0,1], \tag{2}\] <p>where \(\tau_t\) and \(\omega_t\) solve</p> \[\frac{\alpha_{\tau_t}}{\beta_{\tau_t}} = \frac{\alpha'_t}{\beta'_t}, \quad \omega_t = \frac{\alpha_{\tau_t}}{\alpha'_t} = \frac{\beta_{\tau_t}}{\beta'_t}, \quad \forall t \in (0, 1)\] <p>with the boundary conditions \(\omega_0 = \omega_1 = 1, \tau_0 = 0, \tau_1 = 1.\)</p> </blockquote> <p>In practice, we can determine \(\tau_t\) numerically‚Äîe.g., via a <a href="https://github.com/lqiang67/rectified-flow/blob/main/rectified_flow/flow_components/interpolation_convertor.py" rel="external nofollow noopener" target="_blank">binary search</a>‚Äîor derive an analytic solution in certain simple cases.</p> <div class="l-body"> <figure id="figure-2" style="margin: 1em auto;"> <div style="display: flex;"> <iframe src="/assets/plotly/interp_tau_ddim_spherical.html" frameborder="0" scrolling="no" height="330px" width="50%"></iframe> <iframe src="/assets/plotly/interp_tau_straight_spherical.html" frameborder="0" scrolling="no" height="330px" width="50%"></iframe> </div> <figcaption> <a href="#figure-2">Figure 2</a>. The \(\tau\) and \(\omega\) transformations that convert DDIM to spherical interpolation (left) and convert straight interpolation to spherical (right). When converting DDIM to spherical, \(\omega_t\) remains fixed at 1, because only the time scaling changes. </figcaption> </figure> </div> <p>Combining Proposition 1 with Theorem 1, we have:</p> <blockquote class="definition"> <p><strong>Proposition 2. Rectified Flows between Affine Interpolations</strong></p> <p>For the affine interpolations \(\{X_t\}\) and \(\{X'_t\}\) in Proposition 1, we have</p> <ul> <li>Their rectified flows \(\{Z_t\}\) and \(\{Z'_t\}\) satisfy:</li> </ul> \[Z'_t = \frac 1 {\omega_t} Z_{\tau_t}, \quad \forall t \in [0, 1].\] <ul> <li> <p>Their rectified couplings are identical: \((Z_0, Z_1) = (Z'_0, Z'_1).\)</p> </li> <li> <p>Their rectified flow velocity fields \(v_t\) and \(v'_t\) relate via:</p> </li> </ul> \[v'_t(x) = \frac{\dot{\tau}_t}{\omega_t} v_{\tau_t}(\omega_t x) - \frac{\dot{\omega}_t}{\omega_t} x. \tag{3}\] </blockquote> <blockquote class="example"> <p><strong>Example 1. Velocity from Straight to Affine</strong></p> <p>For the straight interpolation \(X_t=tX_1 + (1-t)X_0\) with \(\alpha_t=t\) and \(\beta_t=1-t\). Convert it into another affine interpolation \(X'_t = \alpha'_t X_1 + \beta'_t X_0\) gives:</p> \[\tau_t = \frac{\alpha'_t}{\alpha'_t + \beta_t'}, \quad \omega_t = \frac{1}{\alpha_t' + \beta_t'}.\] <p>Their rectified flow velocity fields satisfy:</p> \[v'_t(x) = \frac{\dot{\alpha}'_t \beta'_t - \alpha'_t \dot{\beta}'_t}{\alpha'_t + \beta'_t} v_{\tau_t}(\omega_t x) \;+\; \frac{\dot{\alpha}'_t + \dot{\beta}'_t}{\alpha'_t + \beta'_t} x.\] </blockquote> <div class="l-body"> <figure id="figure-3" style="margin: 0em auto;"> <iframe src="/assets/plotly/interp_convert_200step.html" frameborder="0" scrolling="no" height="430px" width="75%"> </iframe> <figcaption> <a href="#figure-3">Figure 3</a>. We first train a rectified flow using straight interpolation, and then transform it into the RF of spherical interpolation by applying the transformation formula described above. While the transformation produces different ODE trajectories, both ultimately converge to the same endpoint \(Z_1\), as predicted by Proposition 2. The result is obtained by solving the ODE using 100 Euler steps. </figcaption> </figure> </div> <h3 id="implication-on-inference">Implication on Inference</h3> <p>The trajectories of the RF derived from different affine interpolations can be viewed as deformations of one another via time and space scaling. When the same numerical discretization methods, such as the Euler method, are applied to these differently deformed trajectories, they produce varying discretization errors, leading to different results. This difference becomes pronounced when a large step size is used, as it introduces significant discretization errors (see <a href="#figure-4">Figure 4</a> for the results of the Euler method with 4 steps). However, the difference diminishes as the discretization becomes sufficiently fine to accurately approximate the underlying ODEs (as shown in <a href="#figure-3">Figure 3</a> with 100 Euler steps).</p> <p><a href="#figure-5">Figure 5</a> illustrates how the difference in the inference results for the predicted outcome \(Z_1\) of the RF ODEs corresponding to straight and spherical interpolation decreases as the number of Euler steps increases.</p> <div class="l-body"> <figure id="figure-4" style="margin: 0em auto;"> <div style="display: flex;"> <iframe src="/assets/plotly/interp_convert_10step_straight.html" frameborder="0" scrolling="no" height="330px" width="50%"></iframe> <iframe src="/assets/plotly/interp_convert_10step_spherical.html" frameborder="0" scrolling="no" height="330px" width="50%"></iframe> </div> <figcaption> <a href="#figure-4">Figure 4</a>. Different final generated samples when the number of Euler steps is reduced to 4. </figcaption> </figure> </div> <div class="l-body"> <figure id="figure-5" style="margin: 1em auto;"> <div style="display: flex; justify-content: center;"> <iframe src="/assets/plotly/interp_mse_step.html" frameborder="0" scrolling="no" height="310px" width="60%"> </iframe> </div> <figcaption> <a href="#figure-5">Figure 5</a>. The mean square error (MSE) between the estimtion of \(Z_1\) from rectified flows induced from straight versus spherical interpolation decreases as the number of inference steps increases, reflecting their shared continuous-time limit. Nevertheless, different discretization schemes produce varying performance when the step count is small. </figcaption> </figure> </div> <p>In general, we may want to reduce these errors by seeking ‚Äústraighter‚Äù trajectories when the Euler method is used for discretization. Note, however, if ‚Äúcurved‚Äù variants of the Euler method are employed, the notion of straightness must be adapted to account for the curvature inherent in the curved Euler method. For further discussion, refer to <a href="https://rectifiedflow.github.io/blog/2024/discretization/" rel="external nofollow noopener" target="_blank">this blog</a>.</p> <p>Although it is challenging to predict the best inference interpolation scheme <em>a priori</em>, post-training conversion allows us to choose whichever scheme yields better sampling results in practice. Moreover, one can go a step further by directly optimizing the pointwise transform to minimize discretization error, without worrying about which interpolation scheme it corresponds to. Specifically, this involves directly finding the pair \((\phi_t, \tau_t)\) such that the Euler method applied to the transformed ODE, \(Z_t' = \phi_t(Z_{\tau_t})\), is as accurate as possible.</p> <h2 id="implications-on-loss-functions">Implications on Loss Functions</h2> <p>Suppose we have a parametric model \(v_t(x;\theta)\) trained to approximate the RF velocity field \(v_t(x)\) under a specific affine interpolation. After training, we can use the relationships derived above to convert this model into \(v'_t(x;\theta)\), corresponding to a different affine interpolation, without retraining.</p> <p>This leads to two related questions:</p> <p>1) How does training with one interpolation differ from converting an RF trained with another interpolation?</p> <p>2) Does post-training conversion between models degrade performance?</p> <p>It turns out that choosing a different affine interpolation during training is equivalent to changing the <strong>time-weighting</strong> in the loss function and applying an affine transform to the model parameterization. As long as the transformations \(\omega_t\) and \(\tau_t\) are not highly singular, converting a model from one affine interpolation to another may not impact the performance dramatically.</p> <p>Consider a model \(v_t(x; \theta)\) trained to approximate the RF velocity \(v_t\) of interpolation \(X_t = \alpha_t X_1 + \beta_t X_0\) by minimizing a time-weighted mean square loss:</p> \[\mathcal L(\theta) = \int_0^1 \mathbb E\left[ \eta_t \left \| \dot X_t - v_t(X_t;\theta)\right\|^2 \right] \mathrm dt,\tag{4}\] <p>where \(\eta_t\) is a positive time-weighting function.</p> <p>After training, we can convert this model \(v_t(x; \theta)\) into an approximation \(v'_t(x; \theta)\) of \(v'_t\) of a different interpolation \(X'_t = \alpha_t' X_1 + \beta_t' X_0\) via:</p> \[v'_t(x; \theta) = \frac{\dot{\tau}_t}{\omega_t} v_{\tau_t}(\omega_t x; \theta) - \frac{\dot{\omega}_t}{\omega_t} x.\] <p>On the other hand, if we were to train \(v'_t(x; \theta)\) directly to approximate the velocity \(v'_t\) of interpolation \(X'_t = \alpha'_t X_1 + \beta'_t X_0\), the loss function is:</p> \[\mathcal L'(\theta) = \int_0^1 \mathbb{E} \left[ \eta'_t \left\| \dot{X}'_t - v'_t(X'_t; \theta) \right\|^2 \right] \mathrm dt \tag{5}\] <p>Matching the loss \((4)\) and \((5)\), shows that the two training schemes differ only in time-weighting and parameterization. Specifically,</p> \[\eta'_t = \frac{\omega_t^2}{\dot{\tau}_t} \eta_{\tau_t}, \quad v'_t(x; \theta) = \frac{\dot{\tau}_t}{\omega_t} v_{\tau_t}(\omega_t x; \theta) - \frac{\dot{\omega}_t}{\omega_t} x. \tag{6}\] <p>In other words, <strong>training under different affine interpolation schemes is equivalent to applying a different time-weighting function and a corresponding model reparameterization.</strong></p> <blockquote class="example"> <p><strong>Example 2. Loss from Straight to Affine</strong></p> <p>Consider the straight interpolation \(X_t = t X_1 + (1 - t) X_0\) and another affine interpolation \(X_t' = \alpha_t' X_1 + \beta_t' X_0.\)</p> <p>Suppose we have trained a model \(v_t(x, \theta)\) for the straight interpolation with time weights \(\eta_t.\) Then converted \(v_t'(x, \theta)\) corresponds to the RF trained with the parametrization in \((6)\), and a different time-weighting:</p> \[\eta_t' = \frac{\omega_t^2}{\tau_t'} \eta_{\tau_t} = \frac{1}{\dot{\alpha}_t' \beta_t' - \alpha_t' \dot{\beta}_t'} \eta_{\tau_t}.\] <p>Here, we substitute the relationships derived in Example 1 into \((6)\).</p> </blockquote> <h3 id="straight-vs-spherical-identical-training-loss-with-uniform-weights">Straight vs. Spherical: Identical Training Loss With Uniform Weights</h3> <p>Following Example 2, an interesting case arises when \(\dot{\alpha}'_t \beta'_t - \alpha'_t \dot{\beta}'_t\) is constant, in which case \(\eta'_t\) is proportional to \(\eta_{\tau_t}\). Furthermore, if \(\eta_t = 1\) is uniform, then \(\eta'_t\) is also uniform, which implies the two interpolation schemes share the <em>same</em> loss function in this case.</p> <blockquote class="example"> <p><strong>Example 3. Losses for Straight vs. Spherical Interpolation</strong></p> <p>Consider the spherical interpolation: \(X'_t = \sin\left(\frac{\pi t}{2}\right)X_1 + \cos\left(\frac{\pi t}{2}\right)X_0.\)</p> <p>For this choice, \(\dot{\alpha}'_t \beta'_t - \alpha'_t \dot{\beta}'_t = \frac{\pi}{2}\). Hence:</p> \[\eta'_t = \frac{2}{\pi}\eta_{\tau_t}, \quad \tau_t = \frac{\tan\left(\frac{\pi t}{2}\right)}{\tan\left(\frac{\pi t}{2}\right)+1}.\] <p>Thus, training \(v_t(x,\theta)\) for the straight interpolation with a uniform weight (\(\eta_t=1\)) is equivalent to training \(v'_t(x, \theta)\) for the spherical interpolation also with a uniform weight (\(\eta'_t=2/\pi\)). In this case, the only difference in training for these two interpolations is the reparameterization of the model:</p> \[v'_t(x, \theta) = \frac{\pi \omega_t}{2} \left( v_{\tau_t}(\omega_t x; \theta) + \left( \cos\left(\frac{\pi t}{2}\right) - \sin\left(\frac{\pi t}{2}\right) \right) x \right),\] <p>where \(\omega_t = (\sin(\frac{\pi t}{2}) + \cos(\frac{\pi t}{2}))^{-1}\) is bounded within \([1/\sqrt{2}, 1]\).</p> <p>This reparameterization is quite ‚Äúminor‚Äù and does not seem to impact model quality significantly. As shown <a href="#figure-5">Figure 5</a> below, training with straight or spherical interpolation and uniform loss weighting produces nearly identical results.</p> </blockquote> <div class="l-body"> <figure id="figure-6" style="margin: 0em auto;"> <iframe src="/assets/plotly/interp_convert_double_rf.html" frameborder="0" scrolling="no" height="430px" width="75%"> </iframe> <figcaption> <a href="#figure-6">Figure 6</a>. Training the RF with straight and spherical interpolations using uniform weights yields similar results. The blue curve represents the RF trained with spherical interpolation, while the red curve represents the RF trained with straight interpolation and then converted to spherical interpolation. Since both share the same loss function, as shown in Example 3, the only difference lies in model parameterization, which appears to have limited impact on performance in this case. </figcaption> </figure> </div> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/reference.bib"></d-bibliography> </div> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script>let searchTheme=determineComputedTheme();const ninjaKeys=document.querySelector("ninja-keys");"dark"===searchTheme?ninjaKeys.classList.add("dark"):ninjaKeys.classList.remove("dark");const openSearchModal=()=>{const e=$("#navbarNav");e.hasClass("show")&&e.collapse("hide"),ninjaKeys.open()};</script> <script>const ninja=document.querySelector("ninja-keys");ninja.data=[{id:"nav-",title:"",section:"Navigation",handler:()=>{window.location.href="/"}},{id:"nav-home",title:"Home",description:"",section:"Navigation",handler:()=>{window.location.href="/index.html"}},{id:"post-curved-curved-straight-ddim-is-straight-rf",title:"Curved \xd7 Curved = Straight: DDIM is Straight RF",description:"The discretized inference scheme of DDIM corresponds to a curved Euler method on curved trajectories, and is equivalent to the vanilla Euler method applied to straight rectified flow. But the latter is simpler...",section:"Posts",handler:()=>{window.location.href="/blog/2024/DDIM-and-natural-euler/"}},{id:"post-interpolations-all-flows-are-one-flow",title:"Interpolations: All Flows are One Flow",description:"Various interpolation schemes have been suggested in different methods. How do they impact performance? Is the simplest straight-line interpolation enough?",section:"Posts",handler:()=>{window.location.href="/blog/2024/interpolation/"}},{id:"post-flow-to-diffusion-langevin-is-a-guardrail",title:"Flow to Diffusion: Langevin is a Guardrail",description:"It is known that we can convert between diffusion (SDE) and flow (ODE) models at inference time without retraining. But how is this possible? What is the intuition and purpose? What are the pros and cons of diffusion vs. flow?",section:"Posts",handler:()=>{window.location.href="/blog/2024/diffusion/"}},{id:"post-rectified-flow-straight-is-fast",title:"Rectified Flow: Straight is Fast",description:"Rectified flow learns ODEs as generative models by causalizing (or rectifying) an interpolation process that smoothly connects noise and data. This process naturally favors dynamics with straighter trajectories and hence fast Euler discretization, and can be repeated to further improve straightness.",section:"Posts",handler:()=>{window.location.href="/blog/2024/intro/"}},{id:"socials-email",title:"Send email",section:"Socials",handler:()=>{window.open("mailto:%72%65%63%74%69%66%69%65%64%66%6C%6F%77@%67%6D%61%69%6C.%63%6F%6D","_blank")}},{id:"socials-google-scholar",title:"Google Scholar",section:"Socials",handler:()=>{window.open("https://scholar.google.com/citations?user=XEx1fZkAAAAJ","_blank")}},{id:"light-theme",title:"Change theme to light",description:"Change the theme of the site to Light",section:"Theme",handler:()=>{setThemeSetting("light")}},{id:"dark-theme",title:"Change theme to dark",description:"Change the theme of the site to Dark",section:"Theme",handler:()=>{setThemeSetting("dark")}},{id:"system-theme",title:"Use system default theme",description:"Change the theme of the site to System Default",section:"Theme",handler:()=>{setThemeSetting("system")}}];</script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>